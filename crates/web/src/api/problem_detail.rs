use crate::api::trn::Trn;
use actix_web::{http, HttpResponse};
use serde::Serialize;
use url::Url;
use uuid::Uuid;

/// A problem detail
///
/// # Details
///
/// From RFC-7807
/// "problem detail" is a way to carry machine-readable details of errors in a HTTP response to avoid
/// the need to define new error response formats for HTTP APIs.
#[derive(Debug, Serialize, Clone)]
pub struct ProblemDetail {
    /// A URI reference (RFC-3986) that identifies the problem type. This specification
    /// encourages that, when dereferenced, it provide human-readable documentation for the
    /// problem type (e.g., using HTML). When this member is not present,
    /// its value is assumed to be "about:blank".
    #[serde(rename(serialize = "type"))]
    pub problem_type: Url,
    /// A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence
    /// to occurrence of the problem, except for purposes of localization(e.g., using proactive
    /// content negotiation; see RFC-7231, Section 3.4).
    pub title: String,
    /// A human-readable explanation specific to this occurrence of the problem.
    pub detail: String,
    /// The HTTP status code(RFC-7231, Section 6) generated by the origin server for this
    /// occurrence of the problem.
    pub status: u16,
    /// A TRN reference that identifies the specific occurrence of the problem.
    /// It may or may not yield further information if dereferenced.
    pub instance: Trn,
}

static PROBLEM_DETAIL_CONTENT_TYPE: &str = "application/problem+json";

impl ProblemDetail {
    /// Creates a new problem detail from an error
    pub fn from_error(id: Uuid, error: &str) -> ProblemDetail {
        let type_url = Url::parse("https://httpstatuses.com/500").unwrap();
        ProblemDetail {
            problem_type: type_url,
            title: String::from("Error: Internal Server Error"),
            detail: error.to_owned(),
            status: http::StatusCode::INTERNAL_SERVER_ERROR.as_u16(),
            instance: Trn::instance(&id),
        }
    }

    pub fn to_response(&self) -> HttpResponse {
        HttpResponse::InternalServerError()
            .content_type(PROBLEM_DETAIL_CONTENT_TYPE)
            .json(self)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod problem_details {
        use super::*;
        use pretty_assertions::assert_eq;

        #[test]
        fn it_should_create_a_new_problem_detail_from_errors() {
            let id = Uuid::new_v4();
            let instance_id = Trn::instance(&id);
            let error = "my first error";
            let type_url = Url::parse("https://httpstatuses.com/500").unwrap();

            let problem_detail = ProblemDetail::from_error(id, error);

            assert_eq!(type_url, problem_detail.problem_type);
            assert_eq!("Error: Internal Server Error", problem_detail.title);
            assert_eq!(error, problem_detail.detail);
            assert_eq!(500, problem_detail.status);
            assert_eq!(instance_id, problem_detail.instance);
        }
    }
}
